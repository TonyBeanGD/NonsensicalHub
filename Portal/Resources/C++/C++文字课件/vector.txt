/*-----------------本节课内容--------------------------------
	STL线性顺序容器 --- vector
	1、什么是vector ----------- 了解
	2、vector中的成员函数   --- 重点
	3、vector中的异常处理   --- 了解
-------------------------------------------------------------
一、什么是vector 
1、初识vector
    A、从顺序容器的定义来看：
	   1) vector是顺序性容器，是相同数据类型元素的有序集合。其有序是指元素在容器中的位置由元素插入的次数决定。
	   2) vector是一种各元素之间有次序关系的线性表。
							 
	B、从包含的数据结构思想来看，vector类是一种线性顺序表的类模板实现。

2、vector的分析
	依旧从数据结构的三个方面对vector的进行描述：
		A、逻辑结构：线性逻辑结构，数据元素之间一对一关系，数据元素有序。
		B、存储结构：顺序存储结构，数据元素依次连续存储。
					 随着数据元素的加入，其存储空间能自动扩充。
		C、运算：
		   A、只能在表尾的一端进行插入和删除数据元素
		   B、能直接访问容器内任何元素
	
	小结：
		A、vector类似动态数组，且其大小可以不预先指定，并且自动扩展。
			--- 考虑可以用 动态数组来实现 其属性，但标准并未要求必须用动态数组来实现。
			
		B、vector思想示意：
											   尾部
		   -------------------------------------  <<======
		   |   |   |   |   |   |   |   |   |   |           进行插入/删除数据元素
		   -------------------------------------  ======>>
			 0   1   2   3   4   5   ......
		 
3、vector的特点
    A、vector存放数据元素时，是将其复制到内部的“动态数组”中，且元素根据插入顺序而有次序。
	      --- 重点注意：这就要求放入vector容器内的数据元素 能进行拷贝和赋值操作。
		  
    B、vector支持随机存取，大小能够自动扩展
    C、vector在末端插入或删除元素，且性能相当好
	
    D、所谓动态增加大小，并不是在原空间之后持续新空间，  ---- 重要
       而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，
       并释放原空间。 ---  ”配置新空间/移动数据/释放旧空间”的大工程
	  
4、vector使用注意事项 --- 核心：vector容量问题
    A、对vector的任何操作，一旦引起内存空间重新配置，原vector相关的指针、引用、指向原vector的所有迭代器
	   就都失效了。
	   
    B、当动态添加的数据超过vector默认分配的大小时要进行内存的重新分配、拷贝与释放，
	   这个操作非常消耗性能，费时。
	   (要vector达到最优的性能，最好在创建vector时，就根据使用需要指定其空间大小。)
	   
	C、在vector内部进行插入、删除操作效率非常低，这样的操作基本上是被禁止的。  --- 扬长避短
       (vector 被设计成只能在后端进行追加和删除操作，其原因是vector内部的实现是按照顺序表的原理。)  
	   
	   
二、vector中的函数
    vector是已实现好的类模板，在了解上述内容后，我们可以当作一种数据结构类直接使用它。
	
	vector类是定义在std的namespace 内的模板类，使用之前必须包含头文件<vector>，使用方式如下：
	#include<vector>
	using namespace std;
	
	已有vector类模板实现的情况下，重点关注放在vector类的行为/成员函数上，其属性(存储结构的实现)需要再关注。
	
    下面从几个角度，重点查看vector类的函数/行为。
	
1、vector中容量相关的函数 --- vector容器的自增长问题 --- 指向相关的东东会有失效的可能。
   当插入数据元素个数，超出vector对象的容量capacity时，vector对象的内存空间会自动重新分配。
   在vector的使用过程中，尽量避免原vector的内存空间被进行重新分配，如有则需要，对这种情况给予关注。
   
    进一步学习前，明确概念：
		A、容器的capacity容量和容器size长度的关系：
		  size是指当前容器拥有的元素个数，
		  capacity是指容器在必须分配新存储空间之前可以存储的元素总数。//？
		  
		B、当显式新建一个空vector对象时，其保留空间大小和容器元素个数均为0。
		   当插入元素个数超出vector对象的capacity，就会引起vector内存重新分配。
		  
		C、vector类提供函数reserve来预留空间，增加vector的容量capacity，
		   尽量避免原vector的内存空间被进行重新分配。
		
	图示：
	   -------------------------------------------    
	   | 0  | 1  | 2  | 3  |  4  |    预留空间   |         
	   -------------------------------------------  
                               v1.size         v1.capacity
      
    vector类中提供了两个函数来帮助解决这个问题：---- vector对象内存重新分配的问题
		A、reserve：用户手动定义vector的容量大小。
		B、capacity: 获取当前vector的容量大小,当前容器进行内存重新分配前能够存储的元素总数		  
	   (C、size: 获取当前vector拥有的元素个数)
	   
2、容器的初始化/销毁  --- 构造函数/析构函数
    //---------容器适用-------------- container
    A、vector<Type> cName;            //产生一个名cName的空容器，其中没有任何元素
    B、vector<Type> cName2(cName1);   //创建了cName1的副本cName2，两者数据类型和容器类型均相同，
	                                  //所有数据元素被拷贝
	C、vector<Type> cName(begin,end); //创建一个vector，其元素是区间[begin,end)内的数据元素的副本
    
	//---------我是分割线-----下面两个方法，只适用顺序容器--------------
    D、vector<Type> cName(n);         //创建包含 n个有初值的数据元素的容器，容器大小为n。
                                      //初值 --- 取决于数据元素的构造函数。
    E、vector<Type> cName(n,element); //产生一个大小为n的vector，每个元素均为element
    F、cName.~vector<Type>();         //销毁所有数据元素，并释放内存

3、顺序容器的大小相关
    A、cName.size();             //返回容器中拥有的元素个数，返回值类型：cName::size_type
	B、cName.max_size();         //返回容器可容纳的元素最大数
    C、cName.empty();            //返回容器大小是否为0的布尔值
	D、cName.resize(n);          //调整容器的大小为 n，n<c.size(),删除多的元素，
	                             //反之，添加初始化新的元素（由构造函数决定）。
	E、cName.resize(n,element);  //调整容器的大小为 n，n<c.size(),删除多的元素，反之，添加新的元素element。

4、访问顺序容器的元素   -------------------- 查询
    A、c.back();           //返回容器c最后一个元素的引用。如c为空，则该操作未定义 
    B、c.front();          //返回容器c第一个元素的引用。如c为空，则该操作未定义	
	
    //---------我是分割线-----下面两个方法，只适用顺序容器vector、deque--------------	
    C、c[n];               //返回容器c中下标为n的元素的引用。
	                       //如n<0或n>c.size()，这该操作未定义
    D、c.at(n);            //返回容器c中下标为n的元素的引用。
	                       //如n<0或n>c.size()，该操作会抛出异常，建议使用 	
					   
5、删除顺序容器的元素   -------------------- 删除
   A、c.clear();          //删除容器C内所有元素，返回void
   B、c.pop_back();       //删除容器c最后一个元素，返回void。 如c为空，则该操作未定义
   C、c.erase(itr);       //删除itr所指向的元素，返回删除元素的下一个元素的迭代器
   D、c.erase(itr_begin,itr_end);     //删除由迭代器确定范围[itr_begin,itr_end)内的所有元素
                                      //返回删除区间的下一个元素的迭代器
									  
   //---------我是分割线-----下面两个方法，只适用顺序容器list、deque--------------	
   C、c.pop_front();      //删除容器c第一个元素，返回void。 如c为空，则该操作未定义 
   
6、添加顺序容器的元素   -------------------- 增加	
   A、c.push_back(element);                //在容器c的尾部添加元素element，返回void       
   B、c.insert(itr,element);               //在itr所指向的元素前插入新元素element，返回指向新元素的迭代器
   C、c.insert(itr,n,element);             //在itr所指向的元素前插入n个值为element新元素，返回void类型
   D、c.insert(itr,itr_begin,itr_end);     //在itr所指向的元素前，
                                           //插入由迭代器确定范围[itr_begin,itr_end)内的所有元素
                                           //返回void类型
										   
   //---------我是分割线-----下面两个方法，只适用顺序容器list、deque--------------	
   E、c.push_front();      ////在容器c的头部添加元素element，返回void 
	
7、容器迭代器相关的函数
   A、c.begin();
   B、c.end();
   C、c.rbegin();     //返回逆向的迭代器，指向容器的最后一个元素
   D、c.rend();	
     // eg: reverse_iterator
	 
	=== 重点注意: 迭代器失效情况  --- 无效迭代器的操作是未定义的 --- 需要工程师自己注意
	              A、迭代器指向的元素已删除或被移动或不存在
		          B、容器内存重新分配
		  
8、顺序容器赋值相关的函数
   A、c1 = c2;             //删除c1所有元素，将c2元素复制给c1，两者数据类型、容器类型必须一样
   B、c1.swap(c2);         //完全交换c1、c2容器中的所有元素，两者数据类型、容器类型必须一样
   C、c1.assgin(itr2_begin,itr2_end);      //删除c1所有元素，将由迭代器确定范围[itr2_begin,itr2_end)内的外部所有元素
                                           //复制到c1。itr2_begin/itr2_end 必须不是指向c1中的元素。
   D、c1.assgin(n,element);                //删除c1所有元素，将c1容器内的元素设置为n个值为element的元素
   
三、vector中的异常处理
    见PPT课件31页。

*/