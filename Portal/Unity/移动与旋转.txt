一.通过改变坐标移动
	一个GameObjet的Transform共有三个属性：position（位置），rotation（旋转），scale（大小），改变坐标就是改变GameObject的position属性
	1.直接变更坐标
		//将此脚本所挂载的GameObject移动至世界坐标(0,1,0)
		tranform.position=new Vector3(0,1,0);
		或者
		//将【GameObject】移动至世界坐标(0,1,0)
		【GameObject】.tranform.position=new Vector3(0,1,0);（【GameObject】需事先定义并赋值）
	2.以当前坐标为基准改变
		//将此脚本所挂载的GameObject向自己的y轴正方向移动一个单位
		tranform.tranlate(new vector3(0,1,0))
	3.position与localposition
		position是以世界坐标为参照物的坐标，localpositon是以父物体为参照物的坐标，当一个物体没有父物体时，两者相同
		例：A的世界坐标为(0,5,0),B的世界坐标为(0,10,0),将B拖进A中,此时B的Tranform面板显示的position就是localposition,为(0,5,0)
			假如此时挂载在B的脚本有
			void Start()
			{
				tranform.localposition=new vector3(0,0,0);
			}
			一运行B就会和A重叠
二.通过赋予速度和力移动
	刚体组件：
		mass：物体的质量
		drag：物体收到的空气阻力
		Use Gravity：物体是否有重力
		Constraints：
			Freeze Position：冻结坐标
			Freeze Rotation：冻结旋转角
			冻结后无法通过脚本改变被冻结的量，但是可能会因为外界的冲击改变
		（其他几个我也不知道有什么用）
		只有赋予了刚体组件，物体才会有重量，游戏过程中才可能被动的移动（如，被撞动）
	1.赋予物体的刚体速度
		//赋予脚本所挂载的GameObject的Rigidbody一个方向为世界坐标y轴大小为1000单位的速度
		transform.GetComponent<Rigidbody>().velocity = new Vector3(0, 1000, 0);
		//每秒赋予脚本所挂载的GameObject的Rigidbody一个方向为自己y轴正方向大小为1000的速度
		void Update()
		{
			transform.GetComponent<Rigidbody>().velocity = transform.up*Time.deltaTime*1000;
		}
	2.赋予物体的刚体力
		//赋予脚本所挂载的GameObject的Rigidbody一个方向为世界坐标y轴大小为1000单位的力
		transform.GetComponent<Rigidbody>().AddForce(0, 1000, 0);
		//每秒赋予脚本所挂载的GameObject的Rigidbody一个方向为自己z轴正方向大小为1000的力
		void Update()
		{
			transform.GetComponent<Rigidbody>().AddForce(transform.forward*Time.deltaTime*1000);
		}
三.物体的旋转
	1.直接变更旋转角
		//将将此脚本所挂载的GameObject的旋转角变更为(45,45,45)
		transform.rotation = Quaternion.Euler(new Vector3(45, 45, 45));
	2.以当前旋转角为基准改变
		//每秒钟脚本所挂载的GameObject的旋转x轴顺时针旋转15度，y轴逆时针旋转30度，z轴顺时针旋转45度
		void Update()
		{
			transform.Rotate(new Vector3(15, -30, 45)*Time.deltaTime);
		}



脚本实例：
//挂载在想进行移动的物体上
using UnityEngine;

public class move : MonoBehaviour
{
	public GameObject target;	//定义一个游戏对象target
	Rigidbody rb;			//定义一个刚体rb
	public float movingSpeed = 1000;//定义移动速度movingSpeed为1000
	public float rotateSpeed = 100;	//定义旋转速度rotateSpeed为100
	public float jumpSpeed = 30000; //定义跳跃速度jumpSpeed为30000

	// 脚本实例化时运行一次
	private void Awake()
	{
        	rb = target.GetComponent<Rigidbody>();	//将游戏对象的刚体属性赋值给rd
    	}
    	//开始运行时运行一次
    	void Start()
    	{
        
    	}
    	// 每帧运行一次
    	void Update()
    	{
        	Moving();
        	Rotate();
        	Jump();
        	Fly();
    	}
    	void Moving()
    	{
        	if (Input.GetKeyDown(KeyCode.LeftShift))//按下LeftShift时三倍速
        	{
            		movingSpeed = 3000;
        	}
        	if (Input.GetKeyUp(KeyCode.LeftShift))	//放开LeftShift时恢复原来的速度（这里应该用另一个量存储原本速度，因为原本速度可能因为某些游戏要素改变，不再是1000，之前写的，懒得改了）
        	{
            		movingSpeed = 1000;
        	}
        	Vector3 dir = Vector3.zero;	//定义三维向量dir并初始化
        	if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow))	//如果输入w或↑,就会赋值dir向前(物体z轴正方向)
        	{
           	 	dir = target.transform.forward;
        	}
        	if (Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow)) //如果输入s或↓,就会赋值dir向后(物体z轴负方向)
        	{	
        	    	dir = -target.transform.forward;
        	}
        	rb.AddForce(dir * movingSpeed * Time.deltaTime);	//给player施加一个力（方向【dir】*【大小】）
		}
    		void Rotate()	//接受a和d或←和→改变transform的旋转y轴,速度为(rotateSpeed* Time.deltaTime)
    		{
        		float h = Input.GetAxis("Horizontal");	//定义一个h用来获取水平数据
        		transform.Rotate(new Vector3(0, h, 0) * rotateSpeed * Time.deltaTime);  //transform指的是当前挂载的游戏对象
    		}
    		void Jump()	//输入空格时给予一个向上的力（方向【dir】*【大小】）
    		{
        		Vector3 dir = Vector3.zero;
        		if (Input.GetKeyDown(KeyCode.Space))
        		{
            			dir = target.transform.up;
        		}
        		rb.AddForce(dir * jumpSpeed * Time.deltaTime);
    		}
    		void Fly()	//按下f后重力取消，再按一次重力恢复
    		{
        		if (Input.GetKeyDown(KeyCode.F))
           			rb.useGravity =!rb.useGravity
    		}
	}
}