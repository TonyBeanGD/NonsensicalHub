/*-----------------本节课内容--------------------------------
    map容器 --- 非线性容器 ---- 关联容器
	1、pair类简介  ---------------- 了解
	2、什么是map容器   ------------ 理解
	3、map容器的基本操作  ----------重点
    4、map容器的操作总结  ----------重点
-----------------------------------------------------------
引言：
        map在英文中，除了地图的意思，还有映射的概念。在数学里，映射则是个术语，指两个元素的集之间元素相互“对应”的关系。
	这里映射不做特殊说明是指一一映射，根据其概念，可以得到两个具有一一映射关系的元素。
	比如：
		学号 ------- 学生姓名
		游戏账号 --- 游戏角色
        
	那么映射(map)意味着得到：一对具有一一对应关系的两个元素。
	
	对应到计算编程，映射(map)代表具有一一对应关系的两个数据元素。
	
	理解：映射(map)的计算机概念后，那请考虑map容器，存储和组织的数据元素是什么类型？或者是什么样子？
	
一、pair类简介
            根据上述分析，实际使用或游戏中，都有需求：是否有某种数据类型来 形容或表达 一对具有对应关系的数据元素。    
        pair类刚好是这样一种模板类，其pair类对象，包含一对不同数据类型的数据元素，他们之间有对应关系。 
        它定义于标准函数库，该类型在utility头文件中。

    下面从几个方面对pair模板类做简单有效的了解：
        
    1、pair类的对象的创建和初始化
       注意：pair类是模板类，在使用时，需要显式指定两个数据元素的数据类型。
       
       pair<T1,T2> p1;            //创建一个空的pair对象，两个数据类型分别为T1,T2，空具体是指包含指数据元素为空。
                                  //注意：此时pair对象拥有两个有初值（一般为空）的数据元素。
       pair<T1,T2> p1(value1,value2); //创建一个pair对象，两个数据类型分别为T1,T2，数据元素的值分为value1,value2。
       make_pair(value1,value2);      //make_pair是定义于std空间的全局函数，
                                      //以value1，value2值创建一个新的pair对象，其元素类型为value1和value2的数据类型

    2、pair类对象的操作
       对于pair类，其包含的两个数据元素是其成员且均为公有的，在类中分别命名为first和second，其类型依次分别对应<T1,T2>。
       对于pair类对象或指针，可以直接使用直接访问符.或间接访问符号->，分别访问pair类对象的中两个成员的数据成员。
       
       eg：
       pair<int,string> is_pair1(1,"xiaohong");
       cout<<is_pair1.first<<endl;
       cout<<is_pair1.second<<endl;   //是否可用来赋值
       cin>>is_pair1.first>>is_pair1.second;
       
    3、小结：
       A、pair类对象，两个数据元素是对应关系，当多个pair类对象在一起时，为了区分，
          将first对应的数据元素称为key/键，将second对应的数据元素称为value/值。
       
          所有pair类对象可被称为键值对。
       
       B、键值对：1-xiaohong,2-xiaoming,1-xiaoming,3-xiaohong。  
          pair类并不能保证，pair类对象的两个数据元素是一一对应的关系，但起码有对应的关系。

一、什么是map容器
    1、初识map
        A、map是非线性容器，也称为关联容器。
           map容器是已排序的数据元素集合，元素的位置取决于特定的排序准则（一般是根据数据元素的键）。
           注意：次序与元素插入次序无关。

        B、从包含的数据结构思想来看，map类是基于二叉树实现。

    2、map容器类型 --- 模板类
      
       容器是容纳特定类型对象的集合，思考map容器存放的数据元素的类型是什么？ ---- 一种pair数据类型元素。
       eg: map<string,int> si_map1;   //创建一个空的map对象si_map1，其键和值的类型分别为string和int
       
       A、map容器概念
          1)、map是键-值对的集合。map类型通常还被理解为关联数组：可使用键作为下标来获取对应的键值，类似于数组。
       
          2)、在map类型中，数据元素默认是有序的，基于键，按照operator< 进行排序的。
              //按first/键的值，基于operator< 规则排序
             
          3)、map中键和值是一一对应的，不存在相同的键。 --- map容器本身保证。      
              向map容器中添加数据元素时，map函数保证不会引入相同的键。 //insert/[]
              插入新的元素时，会自动按照 排序规则进行排序存储。        //考虑，一个数据元素的键/值是否有必要紧邻存储？
              
          4)、map容器的键类型必须定义和实现 operator< 操作符，而且能正常使用。 --- 用户自定义数据类型需要自己重载
       
       B、map容器的使用
          
          map容器是已实现好的类模板，定义在命令空间std内，
          使用之前必须包含头文件<map>，使用方式如下：
          #include<map>
          using namespace std;
        
          已知map类模板实现的情况下，重点关注放在map类的行为/成员函数上，其属性(存储结构的实现)需要再关注。
          
          下面从几个方面对map类进行深入理解。
          
        1、map类的定义和初始化
           map<T1,T2> m1;      //创建一个名为m的空map，其键和值的类型分别为T1和T2
           map<T1,T2> m2(m1);  //创建m1的副本m2，两者必须有相同键类型和值类型
           map<T1,T2> m3(itr_begin,itr_end);   //创建map类型的对象m3，存储 迭代器[itr_begin;itr_end)标记范围内所有
                                               //数据元素的副本。副本的元素数据类型必须能转化为pair<const T1,T2>
                                               
        2、map类内 定义的数据类型
           前面知道了map内 存放的是pair类型的数据元素，为了更好描述和研究，map类内单个数据元素，
           做了如下数据类型的定义：
           
           map<T1,T2>::key_type      //在map容器中，用作键的数据类型
           map<T1,T2>::mapped_type   //在map容器中，用作值的数据类型
           map<T1,T2>::value_type    //一个对应的具体pair类型，它的first元素具有 const map<T1,T2>::key_type类型，其
                                     //second元素具有map<T1,T2>::mapped_type类型
                                     //可用来定义 与map<T1,T2>内数据元素类型 相同的数据元素 === 重要--pair型
                                     
        3、map类的迭代器分析  -- map<T1,T2>::iterator  ===注意重要
        
           A、map迭代器是 map<T1,T2>内pair类型数据元素的指针 的“封装”，和其他已学的容器有点不同。
              可以通过间接访问符，得到迭代器所指 pair对象的键或值。
           
           B、map迭代器隐含的pair数据类型 map<T1,T2>::value_type
           
           C、map迭代器的解引用 将产生pair类型的对象
	   
三、map容器的基本操作

    在学习定义和初始化map对象后，下面介绍向map添加元素的方法

    1、map::insert成员函数使用
         map<T1,T2> m; 
         m.insert(element);    //elememt 是map<T1,T2>::value_type的pair类对象。
                               //element.first存在于m中，则保持m不变；若不存在，则插入 键值对。
                               //注意：该函数返回一个pair类型的对象：pair < map<T1,T2>::iterator, bool >
                                      迭代器指向键值为element.first的元素
                                      bool值代表是否插入成功。
         element构造方式
             A、map<T1,T2>::value_type e(T1_value,T2_value);
             B、make_pair(T1_value,T2_value);
             
    2、使用下标访问map对象
       map<string,int> si_map1;
       si_map1["xiaohong"] = 17;
       
       过程：在map查看是否存在键"xiaohong"的元素，如不存在，则插入键值对 make_pair("xiaohong",17)到si_map1;
             如存在，则进行键对应数据元素的值更新。 ---- 等效添加数据元素
             
       注意：
          A、用下标访问不存在的元素将导致map容器中添加一个新的元素，它的键即为该下标值。  //好与坏
          B、下标访问的返回值，是特定键所关联的值。
             下标访问的作为左值时，可修改特定键对应值。 //map<T1,T2>::mapped_type
         eg：
            map<string,int> si_map1;
            si_map1["xiaohong"] = 17;
            cout<< si_map1["xiaohong"]<<endl;
            si_map1["xiaohong"]++;
            cout<< si_map1["xiaohong"]<<endl;
                   
四、map容器的操作 ---- 求同存异
    1、map容器共享大部分顺序容器操作，其中不能共用的操作，如下:
		1、不提供front、back、push_front/pop_push、push_back/pop_back操作。  --- map是有序，且是键值对。
		2、不提供 map<string,int> m(n)、map<string,int> m(n,e)形式的初始化。 --- map容器的键是唯一
		3、不提供assign相关的函数
		4、不支持resize、reserve、capacity函数。
		
    2、map容器特有的操作函数 -- 不修改map对象 --const成员函数
	    1、m1.count(key);    //返回map容器m1中键的值为key_val的数据元素的个数
		                         //因为map容器键唯一，故map容器的count函数用来判断
								
		   注意：可用来判断key_val是否存在于m1
								 
		2、m1.find(key);     //检查容器m1中是否存在键的值为key的元素，如存在，则返回指向该元素的迭代器
		                     //如不存在，则返回.end()迭代器 === 重要
                             
		   注意：使用此函数查找元素是否存在，避免[]的在查找时的副作用。 === 重要
		  
		3、查找插入键的值key的下界限和上界限
			iterator lower_bound( const key_type &key1 ) //返回一个迭代器，指向键值 >= key1的第一个元素。
			iterator upper_bound( const key_type &key2 ) //返回一个迭代器，指向键值 > key2的第一个元素。
			pair<map<T1,T2>::iterator,map<T1,T2>::iterator> equal_range( const key_type &key ) 
			//返回上下边界的迭代器的pair对象
		
    3、map容器支持的函数分类如下：
	    A、容器的初始化/销毁  --- 构造函数/析构函数
	        map<T1,T2> m1;            //创建一个名为m的空map，其键和值的类型分别为T1和T2
	        map<T1,T2> m2(m1);        //创建m1的副本m2，两者必须有相同键类型和值类型
	        map<T1,T2> m3(itr_begin,itr_end);  
 		    //创建map类型的对象m3，存储 迭代器[itr_begin;itr_end)标记范围内所有
	        //数据元素的副本。副本的元素数据类型必须能转化为pair<const T1,T2>
		  
		    m1.~map<T1,T2>();                   //销毁所有数据元素，并释放内存	
			//了解
		    map<...> m4(func);                     //以func为排序准则，产生一个空的map //排序准则
		    map<...> m4(itr_begin,itr_end,func);   //以func为排序准则，利用[itr_begin;itr_end)内元素产生一个空的map

	    B、容器的大小相关
		    m1.size();             //返回容器中拥有的元素个数，返回值类型：cName::size_type
			m1.max_size();         //返回容器可容纳的元素最大数
			m1.empty();            //返回容器大小是否为0的布尔值
	
	    C、访问容器的元素   -------------------- 查询
	        m1[key_val];               //m1存在key-value对，返回容器map中key对应的值
	              
            m1.at(key_val);            //返回容器map中key对应的值，如m1中不存在key，报错---注意。
	      //m1.find(hey);
		  
			下标操作的注意：具有危险的副作用，当map容器中，下标操作会插入一个具有该键的新元素。
			map<string,string> m1;
			m1.insert(pair<const int,string>("No1","xiaohong"));
			cout<<m1["No2"]<<endl;  //是否创建了 键值对，值为空
		
        D、删除顺序容器的元素   -------------------- 删除
		    A、m1.clear();            //删除map容器m1内所有元素
		    B、m1.erase(key_val);     //删除键的值为key_val的元素，返回size_type类型，表示删除元素的个数。
		    C、m1.erase(itr);         //删除itr所指向的元素，返回void类型。itr必须指向m中确实存在的元素。
		    D、m1.erase(itr_begin,itr_end);    //删除由m1的迭代器确定有效范围[itr_begin,itr_end)内的所有元素
											   //返回void类型	
            注意：map容器erase删除返回的是void类型。
                  erase还可以接受，key_value类型作为它的函数形参			
	
	    E、添加容器的元素   -------------------- 插入	
	        A、m1.insert(element);                //插入数据类型为value_type的数据元素
		    B、m1.insert(itr_begin,itr_end);      //有[itr_begin,itr_end)范围内同数据类型的元素，
			                                      //数据元素的键不再m1中，则插入此键值对。返回void类型。    
		    C、m1.insert(itr,element);            //在从m1的迭代器itr起，插入同类型的数据元素element。
			                                      //m1存在element.key，则返回m1中key对应的元素的迭代器
												  //m1不存在element.key，插入key-value对。
	    F、容器迭代器相关的函数
		   A、c.begin();
		   B、c.end();
		   C、c.rbegin();     //返回逆向的迭代器，指向容器的最后一个元素
		   D、c.rend();	      // eg: reverse_iterator
	
	    G、容器赋值相关的函数 ---- 两端容器的元素类型必须相同
		   A、m1 = m2;             //删除c1所有元素，将c2元素复制给c1，两者数据类型、容器类型必须一样
		   B、m1.swap(m2);         //完全交换c1、c2容器中的所有元素，两者数据类型、容器类型必须一样
           C、swap(m1,m2);         //同上。此为std中定义的全局函数
		   //不支持assign
		   
		H、容器关系操作符相关  --- 只能用于类型相同的容器
		   A、m1==m2;             //m1、m2具有相同数据元素类型，相同的排序规则 
		                          //自定义规则后，排序规则是map数据类型的一部分
		   B、m1!=m2;
		   C、m1<m2;/m1<=m2;
		   D、m1>m2;/m1>=m2;
*/