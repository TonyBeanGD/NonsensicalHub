/*-----------------本节课内容--------------------------------
	STL线性顺序容器 --- deque --- double end queue -双端队列
	1、什么是deque ----------- 理解
	2、deque中的成员函数   --- 重点
	3、deque中的异常处理   --- 了解
-------------------------------------------------------------
一、什么是deque --- 双端队列
1、初识deque
    A、从顺序容器的定义来看：
	   1) deque是顺序性容器，是相同数据类型元素的有序集合。其有序是指元素在容器中的位置由元素插入的次序决定。
	   2) deque是一种各元素之间有次序关系的“线性表”。
							 
	B、从包含的数据结构思想来看，deque类是一种双端队列的类模板实现。
	
	C、deque是限定插入和删除操作在表的两端进行的线性表。
	D、deque是一种具有队列和栈的性质的数据结构。 ------------------ 回来再看

2、deque的分析
	依旧从数据结构的三个方面对deque的进行描述：
	A、逻辑结构：线性逻辑结构，数据元素之间一对一关系，数据元素有序。 ---一个直接前驱和一个直接后继
	B、运算：
		   1)、能在表头和表尾两端进行插入和删除数据元素
		   2)、能直接访问容器内任何元素
	
	C、存储结构： === 重点
	    deque的存储结构是：分块的顺序存储结构
		    由多个不同的连续内存块组成，每个内存块是线性顺序存储结构，不同内存块间有线性次序关系。
			
	    注意：
		    1)、deque的数据元素，存放在这些不同的连续内存块中，每个内存块称为deque块，块的大小一般为512字节。
		    2)、随着数据元素的加入，deque的存储空间以 deque块的大小 自动扩充。
            3)、deque对象在使用起来就像一整块连续的内存，自动完成deque块间的切换。			

		示意：
		    所有的deque块通过一个Map块进行管理，使得所有deque块，使用起来就像一整块连续的内存。 ---- 注意
		   （了解即可，不用关注实现细节。）
		   
    deque内存结构，简单示意：
                                                                    Map块管理器	 
    表首,插入删除元素                               	              -----                               
        ----------------------------------------	                  |   |        
     <===>	   |   |   |   |   ....... |   |   | deque块 A	 <----    | 1 |    
        ----------------------------------------	                  -----        
                                                                      |   |
        ----------------------------------------  	                  |   |        
        |	|  |   |   |   |   ....... |   |   | deque块 B	 <----    | 2 |   
        ----------------------------------------	                  -----        
                                                                      |   |       
        ----------------------------------------	                  |   |        
        |	|   |   |   |   |  ....... |      <===>  deque块 C  <---- | 3 |    
        ----------------------------------------                      -----   	
                                              表尾,插入删除元素  				 
													  
	小结：
		A、deque和vector类似，采用动态数组的思想来管理数据元素，且其大小可以不预先指定，并且自动扩展。
			
		B、deque提供随机存取数据元素，有着和vector几乎一样的成员函数/接口。
		   不同的是，deque允许在数组的头尾进行数据元素的快速插入和删除
				
		C、deque思想的示意：
                                    表头						     表尾
                           ======>>  -------------------------------------  <<======
        插入/删除数据元素            |   |   |   |   |   |   |   |   |   |            插入/删除数据元素
                           <<======  -------------------------------------  ======>>		   
                                       0   1   2   3   4   5   ......
						   
3、deque的特点 -- 对比vector

    A、具有和vector类似的特点。
        1)、存放数据元素时，是将其复制到内部的“动态数组”中，且元素根据插入顺序而有次序。
	        --- 重点注意：这就要求放入deque容器内的数据元素同样能进行拷贝和赋值操作。  
        2)、支持随机存取，大小能够自动扩展
		3)、中间插入删除数据元素速度都较慢，deque更慢。
	
	B、不同之处
		1)、两端都能够快速插入和删除元素，且性能相当好。vector只能在尾端进行。
		2)、deque的元素插入、删除、查找操作和迭代器操作会稍微慢一些。
		    因为deque的内部结构会多一个间接过程。
            
		3)、deque的迭代器是"特殊的"“智能指针”，它需要在不同的区块之间跳转，但手感一致。  --- 了解下
		    deque迭代器iterator共有4个指针：M_first、M_last、M_cur和M_node。
			   M_node存放当前deque块的Map数据项地址，
			   M_first和M_last分别存放该deque块的首尾元素的地址（M_last实际存放的是deque块的末尾字节的地址），
			   M_cur则存放当前访问的deque双端队列的元素地址。
 
		4)、deque可以包含更多的元素，其max_size可能更大。因为不止使用一块内存。
		
    C、deque不支持对容量和内存分配时机的控制，deque的内存重分配过程优于vector，不必复制所有元素。
	   除了头尾两端, 在任何地方插入和删除元素都将导致内存重分配，原来的迭代器、指针和引用都将失效。 --- 重点关注
	  （deque中没有reserve和capacity成员函数）
	  
	D、deque的内存区块在不被使用时会被释放，也就是deque内存是可以缩减的。具体实现看STL中的实现。
	  
4、deque使用注意事项 
    A、支持随机访问，即支持[]以及at()，但是性能没有vector好。
    B、可以在内部进行插入和删除操作，但性能不及list。   
    C、增加和删除数据元素时，可能会导致内存重新分配   
	D、在deque内部进行插入、删除操作效率非常低，这样的操作基本上不提倡的。  --- 扬长避短
    E、下述情况时，数据结构建议使用deque。
	    需要在两端插入和删除元素
		无需引用容器内的元素
		要求容器释放不再使用的元素
	   
二、deque中的函数
    deque是已实现好的类模板，在了解上述内容后，我们可以当作一种数据结构类直接使用它。
	
	deque类是定义在std的namespace 内的模板类，使用之前必须包含头文件<deque>，使用方式如下：
	#include<deque>
	using namespace std;
	
	已有deque类模板实现的情况下，重点关注放在deque类的行为/成员函数上，其属性(存储结构的实现)需要再关注。
	
    下面从几个角度，重点查看deque类的函数/行为。

===注意：与vector的不同：1、没有容量相关函数；2、增加pop_front/push_front，其他均相同。====
	
1、没有容量相关的函数 --- 没有reserve和capacity成语函数
   
2、容器的初始化/销毁  --- 构造函数/析构函数
    //---------容器适用-------------- container
    A、deque<Type> deqName;              //产生一个名deqName的空容器，其中没有任何元素
    B、deque<Type> deqName2(deqName1);   //创建了deqName1的副本deqName2，两者数据类型和容器类型均相同，
	                                     //所有数据元素被拷贝
	C、deque<Type> deqName(begin,end);   //创建一个deque，其元素是区间[begin,end)内的数据元素的副本
    
	//---------我是分割线-----下面两个方法，只适用顺序容器--------------
    D、deque<Type> deqName(n);           //创建包含 n个有初值的数据元素的容器，容器大小为n。
                                         //初值 --- 取决于数据元素的构造函数。
    E、deque<Type> deqName(n,element);   //产生一个大小为n的deque，每个元素均为element
    F、deqName.~deque<Type>();           //销毁所有数据元素，并释放内存

3、顺序容器的大小相关
    A、deqName.size();                  //返回容器中拥有的元素个数，返回值类型：deqName::size_type
	B、deqName.max_size();              //返回容器可容纳的元素最大数
    C、deqName.empty();                 //返回容器大小是否为0的布尔值
	D、deqName.resize(n);               //调整容器的大小为n，n<deq.size(),删除多的元素，
	                                    //反之，添加初始化新的元素（由构造函数决定）。
	E、deqName.resize(n,element);       //调整容器的大小为n，n<deq.size(),删除多的元素，反之，添加新的元素element。

4、访问顺序容器的元素   -------------------- 查询
    A、deq.back();            //返回容器deq最后一个元素的引用。如c为空，则该操作未定义 
    B、deq.front();           //返回容器deq第一个元素的引用。如c为空，则该操作未定义	
	
    //---------我是分割线-----下面两个方法，只适用顺序容器vector、deque--------------	
    C、deq[n];               //返回容器deq中下标为n的元素的引用。
	                         //如 n<0 或 n>deq.size()，这该操作未定义
    D、deq.at(n);            //返回容器deq中下标为n的元素的引用。
	                         //如 n<0 或 n>deq.size()，该操作会抛出异常，建议使用 	
						   
5、删除顺序容器的元素   -------------------- 删除
   A、deq.clear();          //删除容器deq内所有元素，返回void
   B、deq.pop_back();       //删除容器deq最后一个元素，返回void。 如c为空，则该操作未定义 
   C、deq.pop_front();      //删除容器deq首元素，返回void。 如c为空，则该操作未定义  ------------- 不同1
   D、deq.erase(itr);       //删除itr所指向的元素，返回删除元素的下一个元素的迭代器
   E、deq.erase(itr_begin,itr_end);   //删除由迭代器确定范围[itr_begin,itr_end)内的所有元素
                                      //返回删除区间的下一个元素的迭代器
									  
   //---------我是分割线-----下面两个方法，只适用顺序容器list、deque--------------	
   C、deq.pop_front();      //删除容器deq第一个元素，返回void。 如c为空，则该操作未定义 
   
6、添加顺序容器的元素   -------------------- 插入	
   A、deq.push_back(element);                //在容器deq的尾部添加元素element，返回void  
   B、deq.push_front(element);               //在容器deq的头部添加元素element，返回void   ------------- 不同2   
   C、deq.insert(itr,element);               //在itr所指向的元素前插入新元素element，返回指向新元素的迭代器
   D、deq.insert(itr,n,element);             //在itr所指向的元素前插入n个值为element新元素，返回void类型
   E、deq.insert(itr,itr_begin,itr_end);     //在itr所指向的元素前，
                                             //插入由迭代器确定范围[itr_begin,itr_end)内的所有元素
                                             //返回void类型
										   
   //---------我是分割线-----下面两个方法，只适用顺序容器list、deque--------------	
   E、deq.push_front();                      //在容器deq的头部添加元素element，返回void 
	
7、容器迭代器相关的函数  --- 手感一样
   A、deq.begin();
   B、deq.end();
   C、deq.rbegin();                          //返回特殊的迭代器，指向容器的最后一个元素
   D、deq.rend();	
   // eg: reverse_iterator
	 
	=== 重点注意: 迭代器失效情况  --- 无效迭代器的操作是未定义的 --- 需要工程师自己注意
	              A、迭代器指向的元素已删除或被移动或不存在
		          B、容器内存重新分配 --- deque元素的插入和删除均可能会导致内存重新分配
		  
8、顺序容器赋值相关的函数
   A、deq1 = deq2;             //删除deq1所有元素，将deq2元素复制给deq1，两者数据类型、容器类型必须一样
   B、deq1.swap(deq2);         //完全交换deq1、deq2容器中的所有元素，两者数据类型、容器类型必须一样
   C、deq1.assgin(itr2_begin,itr2_end);    //删除deq1所有元素，将由迭代器确定范围[itr2_begin,itr2_end)内的外部所有元素
                                           //复制到deq1。itr2_begin/itr2_end必须不是指向deq1中的元素。
   D、deq1.assgin(n,element);              //删除deq1所有元素，将deq1容器内的元素设置为n个值为element的元素
   
三、deque中的异常处理
    见PPT课件16页。

*/