c#中的抽象类的特征
抽象类具有以下特性：
抽象类不能实例化。
抽象类可以包含抽象方法和抽象访问器。
不能用 sealed 修饰符修饰抽象类，因为这两个修饰符的含义是相反的。 采用 sealed 修饰符的类无法继承，而 abstract 修饰符要求对类进行继承。
从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实际实现。

与具体类比较
抽象类不能直接实例化，并且对抽象类使用 new 运算符会导致编译时错误。虽然一些变量和值在编译时的类型可以是抽象的，但是这样的变量和值必须或者为 null，或者含有对非抽象类的实例的引用（此非抽象类是从抽象类派生的）。
允许（但不要求）抽象类包含抽象成员。
抽象类不能被密封。

与接口比较
抽象类表示该类中可能已经有一些方法的具体定义，但是接口就仅仅只能定义各个方法的界面（方法名，参数列表，返回类型），并不关心具体细节。
接口是引用类型的，和抽象类的相似之处有三点：
不能实例化；
包含未实现的方法声明；
派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员（不仅是方法包括其他成员）。
抽象类与接口紧密相关。然而接口又比抽象类更抽象，这主要体现在它们的差别上：
类可以实现无限个接口，但仅能从一个抽象（或任何其他类型）类继承，从抽象类派生的类仍可实现接口，从而得出接口是用来解决多重继承问题的。
抽象类当中可以存在非抽象的方法，可接口不能，且它里面的方法只是一个声明必须用public来修饰没有具体实现的方法。
抽象类中的成员变量可以被不同的修饰符来修饰，可接口中的成员变量默认的都是静态常量（static final）。
抽象类是对象的抽象，然而接口是一种行为规范。

C#
抽象类应主要用于关系密切的对象，而接口最适合为不相关的类提供通用功能。
接口着重于CAN-DO关系类型，而抽象类则偏重于IS-A式的关系。
接口多定义对象的行为;抽象类多定义对象的属性。
如果预计会出现版本问题，可以创建“抽象类”。例如，创建了狗（Dog）、鸡（Chicken）和鸭（Duck），那么应该考虑抽象出动物（Animal）来应对以后可能出现猪马牛的事情。而向接口中添加新成员则会强制要求修改所有派生类，并重新编译，所以版本式的问题最好以抽象类来实现。
从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实现。
对抽象类不能使用new关键字，也不能被密封，原因是抽象类不能被实例化。
在抽象方法声明中不能使用 static 或 virtual 修饰符。

抽象方法有以下特征：
1.一个抽象方法可以看作是一个虚函数。 
2.抽象方法的声明只能在抽象类中。 
3.因为抽象方法声明只提供一个无实现的方式，没有方法体 
4.方法体的实现被覆写方法提供，覆写方法是一个非抽象类的成员。 
5.抽象属性的行为和抽象方法相像，除了不同的声明形式。 
6.在一个静态属性中使用abstract 是一个错误。 
*一个抽象属性能够通过派生类使用 override 实现.

抽象类具有以下特征：

1.抽象类不能被实例化。

2.抽象类可以包含抽象方法和访问器

3.不能把抽象类用密封(sealed)来修饰，那就意味着类不能被继承，这违反抽象类被继承的原则。

4.一个派生于一个抽象类的非抽象类必须包括所有的继承来的抽象方法和访问器的实现

5.在方法和属性中使用abstract 关键字意味着包含它们的实现。

